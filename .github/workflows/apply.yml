# .github/workflows/terraform.yml
---

    name: Terraform Apply (Dev)
    
    on:
      push:
        branches:
          - dev
      workflow_dispatch: # Allows manual triggering
    
    jobs:
      terraform:
        name: Apply Terraform to Dev
        runs-on: ubuntu-latest
        environment: dev # Reference your GitHub environment for secrets/variables if configured
    
        # Define AWS Credentials securely at the job level
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          # TF_LOG: DEBUG # Uncomment for detailed Terraform logging if needed
    
        steps:
          - name: Checkout Code
            uses: actions/checkout@v4
    
          # Optional: Clean previous Terraform state/cache if needed
          - name: Clean Terraform Cache (Optional)
            run: rm -rf .terraform .terraform.lock.hcl terraform.tfstate*
            working-directory: ./terraform # Assuming your TF files are in a 'terraform' subdirectory
    
          # --- SSH Key Generation ---
          # Purpose unclear from context. Ensure this is necessary and secure.
          # If creating an aws_key_pair, consider reading the .pub file content into a variable below.
          # If needed for provisioners, consider alternatives like SSM Session Manager for security.
          - name: Generate SSH Key pair (Verify Necessity)
            run: |
              mkdir -p ~/.ssh
              ssh-keygen -t ed25519 -C "gha-runner@github.com" -f ~/.ssh/id_rsa -q -N ""
              chmod 600 ~/.ssh/id_rsa
              echo "SSH Key generated. Ensure its use case is secure and necessary."
              # Example: If you need the public key content for an aws_key_pair resource:
              # echo "GENERATED_PUB_KEY=$(cat ~/.ssh/id_rsa.pub)" >> $GITHUB_ENV
    
          # --- Prepare Terraform Variables ---
          - name: Install jq (JSON Processor)
            run: sudo apt-get update && sudo apt-get install -y jq
    
          - name: Generate Terraform Variable Files
            id: generate_vars
            env:
              # Simple Variables (using secrets directly)
              BUCKETNAME: ${{ secrets.BUCKETNAME }}
              AMI_ID: ${{ secrets.AMI_ID }}
              INSTANCE_TYPE: ${{ secrets.INSTANCE_TYPE }}
              KEY_NAME: ${{ secrets.KEY_NAME }} # Name of the EC2 KeyPair (might relate to SSH key above?)
              PUBLIC_KEY_PATH: ${{ secrets.PUBLIC_KEY_PATH }} # Path to public key? (Verify usage)
              # FILELOCATION_PRTKEY: ${{ secrets.FILELOCATION_PRTKEY }} # Path to private key? (Verify usage - HIGH SECURITY RISK if passing private keys directly)
              VPC_CIDR_BLOCK: ${{ secrets.VPC_CIDR_BLOCK }}
              SUBNET_CIDR_BLOCK: ${{ secrets.SUBNET_CIDR_BLOCK }}
              AVAILABILITY_ZONE: ${{ secrets.AVAILABILITY_ZONE }}
              DESTINATION: ${{ secrets.DESTINATION }} # Purpose unclear, ensure it's used
              EBS_VOLUME_SIZE: ${{ secrets.EBS_VOLUME_SIZE }}
              EBS_VOLUME_TYPE: ${{ secrets.EBS_VOLUME_TYPE }}
              # GENERATED_PUB_KEY: ${{ env.GENERATED_PUB_KEY }} # Uncomment if capturing pub key from previous step
    
              # Complex Variable (Ingress Rules) - Defined as JSON
              # Using '|| null' handles cases where numeric secrets might be missing/empty
              # Ensuring cidr_blocks is correctly formatted as a JSON list of strings
              INGRESS_RULES_INPUT_JSON: |
                [
                  { "from_port": ${{ secrets.INGRESS_FROM_PORT_1 || 'null' }}, "to_port": ${{ secrets.TO_PORT_1 || 'null' }}, "protocol": "${{ secrets.INGRESS_PROTOCOL_1 }}", "cidr_blocks": ["${{ secrets.INGRESS_CIDR_BLOCK_1 }}"] },
                  { "from_port": ${{ secrets.INGRESS_FROM_PORT_2 || 'null' }}, "to_port": ${{ secrets.TO_PORT_2 || 'null' }}, "protocol": "${{ secrets.INGRESS_PROTOCOL_2 }}", "cidr_blocks": ["${{ secrets.INGRESS_CIDR_BLOCK_2 }}"] },
                  { "from_port": ${{ secrets.INGRESS_FROM_PORT_3 || 'null' }}, "to_port": ${{ secrets.TO_PORT_3 || 'null' }}, "protocol": "${{ secrets.INGRESS_PROTOCOL_3 }}", "cidr_blocks": ["${{ secrets.INGRESS_CIDR_BLOCK_3 }}"] },
                  { "from_port": ${{ secrets.INGRESS_FROM_PORT_4 || 'null' }}, "to_port": ${{ secrets.TO_PORT_4 || 'null' }}, "protocol": "${{ secrets.INGRESS_PROTOCOL_4 }}", "cidr_blocks": ["${{ secrets.INGRESS_CIDR_BLOCK_4 }}"] }
                ]
            run: |
              # --- Create terraform.tfvars for simple key-value pairs ---
              echo "# Auto-generated by GitHub Actions - Simple Variables" > terraform.tfvars
              echo "bucketname        = \"$BUCKETNAME\"" >> terraform.tfvars
              echo "ami_id            = \"$AMI_ID\"" >> terraform.tfvars
              echo "instance_type     = \"$INSTANCE_TYPE\"" >> terraform.tfvars
              echo "key_name          = \"$KEY_NAME\"" >> terraform.tfvars
              echo "public_key_path   = \"$PUBLIC_KEY_PATH\"" >> terraform.tfvars
              # echo "filelocation_prtkey = \"$FILELOCATION_PRTKEY\"" >> terraform.tfvars # Avoid passing private key paths if possible
              echo "vpc_cidr_block    = \"$VPC_CIDR_BLOCK\"" >> terraform.tfvars
              echo "subnet_cidr_block = \"$SUBNET_CIDR_BLOCK\"" >> terraform.tfvars
              echo "availability_zone = \"$AVAILABILITY_ZONE\"" >> terraform.tfvars
              echo "destination       = \"$DESTINATION\"" >> terraform.tfvars
              echo "ebs_volume_size   = \"$EBS_VOLUME_SIZE\"" >> terraform.tfvars # Ensure TF variable is number type if needed
              echo "ebs_volume_type   = \"$EBS_VOLUME_TYPE\"" >> terraform.tfvars
              # echo "generated_public_key = \"$GENERATED_PUB_KEY\"" >> terraform.tfvars # Uncomment if needed
    
              echo "Generated terraform.tfvars:"
              cat terraform.tfvars
    
              # --- Create ingress_rules.tfvars.json for the complex list ---
              # Filter out rules where from_port is null (indicating missing primary secret)
              # This ensures we only pass valid rule objects to Terraform
              echo "$INGRESS_RULES_INPUT_JSON" | jq '[.[] | select(.from_port != null and .from_port != "")] | .' > ingress_rules.tfvars.json
    
              echo "Generated ingress_rules.tfvars.json:"
              cat ingress_rules.tfvars.json
    
              # --- Validation (Optional): Check if JSON is valid ---
              if ! jq empty ingress_rules.tfvars.json; then
                echo "ERROR: Generated ingress_rules.tfvars.json is not valid JSON."
                exit 1
              fi
            working-directory: ./terraform # Generate files inside the terraform directory
    
          # --- Generate Backend Configuration ---
          - name: Generate backend-config.tfvars dynamically
            run: |
              echo "# Auto-generated by GitHub Actions - Backend Config" > backend-config.tfvars
              echo "bucket         = \"${{ secrets.TF_BACKEND_BUCKET }}\"" >> backend-config.tfvars
              echo "key            = \"${{ secrets.TF_BACKEND_KEY }}\"" >> backend-config.tfvars
              echo "region         = \"${{ env.AWS_REGION }}\"" >> backend-config.tfvars # Use region from job env
              # Use boolean directly if possible, otherwise ensure TF reads "true" correctly
              echo "encrypt        = true" >> backend-config.tfvars
              # Example for lock table if using DynamoDB
              # echo "dynamodb_table = \"${{ secrets.TF_BACKEND_LOCK_TABLE }}\"" >> backend-config.tfvars
              echo "use_lockfile = \"${{secrets.USELOCKFILE}}\"" >> backend-config.tfvars
    
              echo "Generated backend-config.tfvars"
              cat backend-config.tfvars
            working-directory: ./terraform
    
          # --- Setup and Run Terraform ---
          - name: Set up Terraform
            uses: hashicorp/setup-terraform@v3
            with:
              terraform_version: 1.10.5 # Or use a range like ~1.10 or latest
    
          # Optional: Show generated files for debugging
          - name: Debug - List Generated Files
            run: |
              echo "--- terraform.tfvars ---"
              cat terraform.tfvars || echo "terraform.tfvars not found"
              echo "--- ingress_rules.tfvars.json ---"
              cat ingress_rules.tfvars.json || echo "ingress_rules.tfvars.json not found"
              echo "--- backend-config.tfvars ---"
              cat backend-config.tfvars || echo "backend-config.tfvars not found"
              echo "--- Directory Listing ---"
              ls -la
            working-directory: ./terraform
    
          - name: Terraform Format Check
            id: fmt
            run: terraform fmt -check -recursive
            continue-on-error: true # Optional: Decide if format issues should fail the workflow
            working-directory: ./terraform
    
          - name: Terraform Init
            id: init
            run: terraform init -backend-config=backend-config.tfvars -input=false
            working-directory: ./terraform
    
          - name: Terraform Validate
            id: validate
            run: terraform validate
            working-directory: ./terraform
    
          - name: Terraform Plan
            id: plan
            run: terraform plan -var-file="ingress_rules.tfvars.json" -out=tfplan -input=false
            # Note: terraform.tfvars is loaded automatically by Terraform
            working-directory: ./terraform
    
          - name: Terraform Apply
            id: apply
            run: terraform apply -auto-approve -input=false tfplan
            working-directory: ./terraform
    
          # Optional: Add steps for outputs, cleanup, notifications etc.